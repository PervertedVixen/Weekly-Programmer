<meta charset="utf-8" emacsmode="-*- markdown -*-"><link rel="stylesheet" href="https://casual-effects.com/markdeep/latest/apidoc.css?">

# Weekly Programmer - Week 1

## Baum-Sweet Sequence

From [Weekly Programmer Challenges](./index.html)

## Description

In mathematics, the Baumâ€“Sweet sequence is an infinite automatic sequence of 0s
and 1s defined by the rule:

* b_n = 1 if the binary representation of n contains no block of consecutive 0s
    of odd length;
* b_n = 0 otherwise;

for n >= 0.

For example, b_4 = 1 because the binary representation of 4 is 100, which only
contains one block of consecutive 0s of length 2; whereas b_5 = 0 because the
binary representation of 5 is 101, which contains a block of consecutive 0s of
length 1. When n is 19611206, b_n is 0 because:

```text
19611206 = 1001010110011111001000110 base 2
            00 0 0  00     00 000  0 runs of 0s
               ^ ^            ^^^    odd length sequence
```

Because we find an odd length sequence of 0s, b_n is 0.

## Challenge Description

Your challenge today is to write a program that generates the Baum-Sweet
sequence from 0 to some number n. For example, given "20" your program would emit:

`1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0`

## Example Solution

Language: Javascript

```javascript
const baumSweet = n => /1(00)*0(1|$)/.test(n.toString(2)) ? 0 : 1;
const baumSweetSeq = n => new Array(n + 1).fill().map((_,n) => baumSweet(n));
console.log(baumSweetSeq(20).join(', '));
```

## Solution Explanation

Breaking this down the core of the solution is the `baumSweet` function. This.
function takes a number and returns the baumsweet number for it. This conversion
is performed via regular expression matching.

We know that:

* any binary number starts with a `1` (Leading zeros are not produced by the
    Numeric toString method)
* an odd length sequence of `0` is zero or more instances of `00` followed by a
    lone `0`

Using these two facts we construct the regular expression `/1(00)*0(1|$)/`, that
is "Match `1` followed by zero or more repetitions of `00`, followed by `0`,
followed by `1` or end of input. Using this regular expression we test the base 2
representation of the input number and return `0` if there is a match and `1` otherwise.

The other bit of subtlty appears in the `baumSweetSeq` function.

<script>markdeepOptions={tocStyle:'medium'};</script>
<!-- Markdeep: --><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js?"></script>
